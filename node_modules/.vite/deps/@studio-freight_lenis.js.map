{
  "version": 3,
  "sources": ["../../@studio-freight/lenis/src/maths.js", "../../@studio-freight/lenis/src/animate.js", "../../@studio-freight/lenis/src/debounce.js", "../../@studio-freight/lenis/src/dimensions.js", "../../@studio-freight/lenis/src/nanoevents.js", "../../@studio-freight/lenis/src/virtual-scroll.js", "../../@studio-freight/lenis/src/index.js"],
  "sourcesContent": ["// Clamp a value between a minimum and maximum value\nexport function clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max))\n}\n\n// Truncate a floating-point number to a specified number of decimal places\nexport function truncate(value, decimals = 0) {\n  return parseFloat(value.toFixed(decimals))\n}\n\n// Linearly interpolate between two values using an amount (0 <= t <= 1)\nexport function lerp(x, y, t) {\n  return (1 - t) * x + t * y\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nexport function damp(x, y, lambda, dt) {\n  return lerp(x, y, 1 - Math.exp(-lambda * dt))\n}\n\n// Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\n// https://anguscroll.com/just/just-modulo\nexport function modulo(n, d) {\n  return ((n % d) + d) % d\n}\n", "import { clamp, damp } from './maths'\n\n// Animate class to handle value animations with lerping or easing\nexport class Animate {\n  // Advance the animation by the given delta time\n  advance(deltaTime) {\n    if (!this.isRunning) return\n\n    let completed = false\n\n    if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to\n        completed = true\n      }\n    } else {\n      this.currentTime += deltaTime\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\n\n      completed = linearProgress >= 1\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\n      this.value = this.from + (this.to - this.from) * easedProgress\n    }\n\n    // Call the onUpdate callback with the current value and completed status\n    this.onUpdate?.(this.value, { completed })\n\n    if (completed) {\n      this.stop()\n    }\n  }\n\n  // Stop the animation\n  stop() {\n    this.isRunning = false\n  }\n\n  // Set up the animation from a starting value to an ending value\n  // with optional parameters for lerping, duration, easing, and onUpdate callback\n  fromTo(from, to, { lerp = 0.1, duration = 1, easing = (t) => t, onUpdate }) {\n    this.from = this.value = from\n    this.to = to\n    this.lerp = lerp\n    this.duration = duration\n    this.easing = easing\n    this.currentTime = 0\n    this.isRunning = true\n\n    this.onUpdate = onUpdate\n  }\n}\n", "export function debounce(callback, delay) {\n  let timer\n  return function () {\n    let args = arguments\n    let context = this\n    clearTimeout(timer)\n    timer = setTimeout(function () {\n      callback.apply(context, args)\n    }, delay)\n  }\n}\n", "import { debounce } from './debounce'\n\nexport class Dimensions {\n  constructor(wrapper, content) {\n    this.wrapper = wrapper\n    this.content = content\n\n    if (this.wrapper === window) {\n      window.addEventListener('resize', this.onWindowResize, false)\n      this.onWindowResize()\n    } else {\n      this.wrapperResizeObserver = new ResizeObserver(\n        debounce(this.onWrapperResize, 100)\n      )\n      this.wrapperResizeObserver.observe(this.wrapper)\n      this.onWrapperResize()\n    }\n\n    this.contentResizeObserver = new ResizeObserver(\n      debounce(this.onContentResize, 100)\n    )\n    this.contentResizeObserver.observe(this.content)\n    this.onContentResize()\n  }\n\n  onWindowResize = () => {\n    this.width = window.innerWidth\n    this.height = window.innerHeight\n  }\n\n  destroy() {\n    window.removeEventListener('resize', this.onWindowResize, false)\n\n    this.wrapperResizeObserver?.disconnect()\n    this.contentResizeObserver?.disconnect()\n  }\n\n  onWrapperResize = () => {\n    this.width = this.wrapper.clientWidth\n    this.height = this.wrapper.clientHeight\n  }\n\n  onContentResize = () => {\n    const element =\n      this.wrapper === window ? document.documentElement : this.wrapper\n    this.scrollHeight = element.scrollHeight\n    this.scrollWidth = element.scrollWidth\n  }\n\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height,\n    }\n  }\n}\n", "export let createNanoEvents = () => ({\n  events: {},\n\n  // Emit an event with the provided arguments\n  emit(event, ...args) {\n    let callbacks = this.events[event] || []\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i](...args)\n    }\n  },\n\n  // Register a callback for the specified event\n  on(event, cb) {\n    // Add the callback to the event's callback list, or create a new list with the callback\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\n\n    // Return an unsubscribe function\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\n    }\n  },\n})\n", "import { clamp } from './maths'\nimport { createNanoEvents } from './nanoevents'\n\nexport class VirtualScroll {\n  constructor(\n    element,\n    { wheelMultiplier = 1, touchMultiplier = 2, normalizeWheel = false }\n  ) {\n    this.element = element\n    this.wheelMultiplier = wheelMultiplier\n    this.touchMultiplier = touchMultiplier\n    this.normalizeWheel = normalizeWheel\n\n    this.touchStart = {\n      x: null,\n      y: null,\n    }\n\n    this.emitter = createNanoEvents()\n\n    this.element.addEventListener('wheel', this.onWheel, { passive: false })\n    this.element.addEventListener('touchstart', this.onTouchStart, {\n      passive: false,\n    })\n    this.element.addEventListener('touchmove', this.onTouchMove, {\n      passive: false,\n    })\n    this.element.addEventListener('touchend', this.onTouchEnd, {\n      passive: false,\n    })\n  }\n\n  // Add an event listener for the given event and callback\n  on(event, callback) {\n    return this.emitter.on(event, callback)\n  }\n\n  // Remove all event listeners and clean up\n  destroy() {\n    this.emitter.events = {}\n\n    this.element.removeEventListener('wheel', this.onWheel, {\n      passive: false,\n    })\n    this.element.removeEventListener('touchstart', this.onTouchStart, {\n      passive: false,\n    })\n    this.element.removeEventListener('touchmove', this.onTouchMove, {\n      passive: false,\n    })\n    this.element.removeEventListener('touchend', this.onTouchEnd, {\n      passive: false,\n    })\n  }\n\n  // Event handler for 'touchstart' event\n  onTouchStart = (event) => {\n    const { clientX, clientY } = event.targetTouches\n      ? event.targetTouches[0]\n      : event\n\n    this.touchStart.x = clientX\n    this.touchStart.y = clientY\n\n    this.lastDelta = {\n      x: 0,\n      y: 0,\n    }\n  }\n\n  // Event handler for 'touchmove' event\n  onTouchMove = (event) => {\n    const { clientX, clientY } = event.targetTouches\n      ? event.targetTouches[0]\n      : event\n\n    const deltaX = -(clientX - this.touchStart.x) * this.touchMultiplier\n    const deltaY = -(clientY - this.touchStart.y) * this.touchMultiplier\n\n    this.touchStart.x = clientX\n    this.touchStart.y = clientY\n\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY,\n    }\n\n    this.emitter.emit('scroll', {\n      type: 'touch',\n      deltaX,\n      deltaY,\n      event,\n    })\n  }\n\n  onTouchEnd = (event) => {\n    this.emitter.emit('scroll', {\n      type: 'touch',\n      inertia: true,\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event,\n    })\n  }\n\n  // Event handler for 'wheel' event\n  onWheel = (event) => {\n    let { deltaX, deltaY } = event\n\n    if (this.normalizeWheel) {\n      deltaX = clamp(-100, deltaX, 100)\n      deltaY = clamp(-100, deltaY, 100)\n    }\n\n    deltaX *= this.wheelMultiplier\n    deltaY *= this.wheelMultiplier\n\n    this.emitter.emit('scroll', { type: 'wheel', deltaX, deltaY, event })\n  }\n}\n", "import { version } from '../package.json'\nimport { Animate } from './animate'\nimport { Dimensions } from './dimensions'\nimport { clamp, modulo } from './maths'\nimport { createNanoEvents } from './nanoevents'\nimport { VirtualScroll } from './virtual-scroll'\n\n// Technical explaination\n// - listen to 'wheel' events\n// - prevent 'wheel' event to prevent scroll\n// - normalize wheel delta\n// - add delta to targetScroll\n// - animate scroll to targetScroll (smooth context)\n// - if animation is not running, listen to 'scroll' events (native context)\n\nexport default class Lenis {\n  // isScrolling = true when scroll is animating\n  // isStopped = true if user should not be able to scroll - enable/disable programatically\n  // isSmooth = true if scroll should be animated\n  // isLocked = same as isStopped but enabled/disabled when scroll reaches target\n\n  /**\n   * @typedef {(t: number) => number} EasingFunction\n   * @typedef {'vertical' | 'horizontal'} Orientation\n   * @typedef {'vertical' | 'horizontal' | 'both'} GestureOrientation\n   *\n   * @typedef LenisOptions\n   * @property {Orientation} [direction]\n   * @property {GestureOrientation} [gestureDirection]\n   * @property {number} [mouseMultiplier]\n   * @property {boolean} [smooth]\n   *\n   * @property {Window | HTMLElement} [wrapper]\n   * @property {HTMLElement} [content]\n   * @property {Window | HTMLElement} [wheelEventsTarget]\n   * @property {boolean} [smoothWheel]\n   * @property {boolean} [smoothTouch]\n   * @property {boolean} [syncTouch]\n   * @property {number} [syncTouchLerp]\n   * @property {number} [touchInertiaMultiplier]\n   * @property {number} [duration]\n   * @property {EasingFunction} [easing]\n   * @property {number} [lerp]\n   * @property {boolean} [infinite]\n   * @property {Orientation} [orientation]\n   * @property {GestureOrientation} [gestureOrientation]\n   * @property {number} [touchMultiplier]\n   * @property {number} [wheelMultiplier]\n   * @property {boolean} [normalizeWheel]\n   *\n   * @param {LenisOptions}\n   */\n  constructor({\n    //--legacy options--//\n    direction,\n    gestureDirection,\n    mouseMultiplier,\n    smooth,\n    //--legacy options--//\n    wrapper = window,\n    content = document.documentElement,\n    wheelEventsTarget = wrapper,\n    smoothWheel = smooth ?? true,\n    smoothTouch = false,\n    syncTouch = false,\n    syncTouchLerp = 0.1,\n    touchInertiaMultiplier = 35,\n    duration, // in seconds\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n    lerp = duration ? null : 0.1,\n    infinite = false,\n    orientation = direction ?? 'vertical', // vertical, horizontal\n    gestureOrientation = gestureDirection ?? 'vertical', // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = mouseMultiplier ?? 1,\n    normalizeWheel = false,\n  } = {}) {\n    // warn about legacy options\n    if (direction) {\n      console.warn(\n        'Lenis: `direction` option is deprecated, use `orientation` instead'\n      )\n    }\n    if (gestureDirection) {\n      console.warn(\n        'Lenis: `gestureDirection` option is deprecated, use `gestureOrientation` instead'\n      )\n    }\n    if (mouseMultiplier) {\n      console.warn(\n        'Lenis: `mouseMultiplier` option is deprecated, use `wheelMultiplier` instead'\n      )\n    }\n    if (smooth) {\n      console.warn(\n        'Lenis: `smooth` option is deprecated, use `smoothWheel` instead'\n      )\n    }\n\n    window.lenisVersion = version\n\n    // if wrapper is html or body, fallback to window\n    if (wrapper === document.documentElement || wrapper === document.body) {\n      wrapper = window\n    }\n\n    this.options = {\n      wrapper,\n      content,\n      wheelEventsTarget,\n      smoothWheel,\n      smoothTouch,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaMultiplier,\n      duration,\n      easing,\n      lerp,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      normalizeWheel,\n    }\n\n    this.dimensions = new Dimensions(wrapper, content)\n    this.rootElement.classList.add('lenis')\n\n    this.velocity = 0\n    this.isStopped = false\n    this.isSmooth = smoothWheel || smoothTouch\n    this.isScrolling = false\n    this.targetScroll = this.animatedScroll = this.actualScroll\n    this.animate = new Animate()\n    this.emitter = createNanoEvents()\n\n    this.options.wrapper.addEventListener('scroll', this.onScroll, {\n      passive: false,\n    })\n\n    this.virtualScroll = new VirtualScroll(wheelEventsTarget, {\n      touchMultiplier,\n      wheelMultiplier,\n      normalizeWheel,\n    })\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\n  }\n\n  destroy() {\n    this.emitter.events = {}\n\n    this.options.wrapper.removeEventListener('scroll', this.onScroll, {\n      passive: false,\n    })\n\n    this.virtualScroll.destroy()\n  }\n\n  on(event, callback) {\n    return this.emitter.on(event, callback)\n  }\n\n  off(event, callback) {\n    this.emitter.events[event] = this.emitter.events[event]?.filter(\n      (i) => callback !== i\n    )\n  }\n\n  setScroll(scroll) {\n    // apply scroll value immediately\n    if (this.isHorizontal) {\n      this.rootElement.scrollLeft = scroll\n    } else {\n      this.rootElement.scrollTop = scroll\n    }\n  }\n\n  onVirtualScroll = ({ type, inertia, deltaX, deltaY, event }) => {\n    // keep zoom feature\n    if (event.ctrlKey) return\n\n    const isTouch = type === 'touch'\n    const isWheel = type === 'wheel'\n\n    if (\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) || // trackpad previous/next page gesture\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0) ||\n      (isTouch &&\n        this.options.gestureOrientation === 'vertical' &&\n        this.scroll === 0 &&\n        !this.options.infinite &&\n        deltaY <= 0) // touch pull to refresh\n    )\n      return\n\n    // catch if scrolling on nested scroll elements\n    if (\n      !!event\n        .composedPath()\n        .find((node) => node?.hasAttribute?.('data-lenis-prevent'))\n    )\n      return\n\n    if (this.isStopped || this.isLocked) {\n      event.preventDefault()\n      return\n    }\n\n    this.isSmooth =\n      ((this.options.smoothTouch || this.options.syncTouch) && isTouch) ||\n      (this.options.smoothWheel && isWheel)\n\n    if (!this.isSmooth) {\n      this.isScrolling = false\n      this.animate.stop()\n      return\n    }\n\n    event.preventDefault()\n\n    let delta = deltaY\n    if (this.options.gestureOrientation === 'both') {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\n    } else if (this.options.gestureOrientation === 'horizontal') {\n      delta = deltaX\n    }\n\n    const syncTouch = isTouch && this.options.syncTouch\n    const hasTouchInertia = isTouch && inertia && Math.abs(delta) > 1\n    if (hasTouchInertia) {\n      delta = this.velocity * this.options.touchInertiaMultiplier\n    }\n\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...(syncTouch && {\n        lerp: hasTouchInertia ? this.syncTouchLerp : 0.4, // should be 1 but had to leave 0.4 for iOS.....\n      }),\n    })\n  }\n\n  emit() {\n    this.emitter.emit('scroll', this)\n  }\n\n  onScroll = () => {\n    if (!this.isScrolling) {\n      const lastScroll = this.animatedScroll\n      this.animatedScroll = this.targetScroll = this.actualScroll\n      this.velocity = 0\n      this.direction = Math.sign(this.animatedScroll - lastScroll)\n      this.emit()\n    }\n  }\n\n  reset() {\n    this.isLocked = false\n    this.isScrolling = false\n    this.velocity = 0\n    this.animate.stop()\n  }\n\n  start() {\n    this.isStopped = false\n\n    this.reset()\n  }\n\n  stop() {\n    this.isStopped = true\n    this.animate.stop()\n\n    this.reset()\n  }\n\n  raf(time) {\n    const deltaTime = time - (this.time || time)\n    this.time = time\n\n    this.animate.advance(deltaTime * 0.001)\n  }\n\n  scrollTo(\n    target,\n    {\n      offset = 0,\n      immediate = false,\n      lock = false,\n      duration = this.options.duration,\n      easing = this.options.easing,\n      lerp = !duration && this.options.lerp,\n      onComplete = null,\n      force = false, // scroll even if stopped\n      programmatic = true, // called from outside of the class\n    } = {}\n  ) {\n    if (this.isStopped && !force) return\n\n    // keywords\n    if (['top', 'left', 'start'].includes(target)) {\n      target = 0\n    } else if (['bottom', 'right', 'end'].includes(target)) {\n      target = this.limit\n    } else {\n      let node\n\n      if (typeof target === 'string') {\n        // CSS selector\n        node = document.querySelector(target)\n      } else if (target?.nodeType) {\n        // Node element\n        node = target\n      }\n\n      if (node) {\n        if (this.options.wrapper !== window) {\n          // nested scroll offset correction\n          const wrapperRect = this.options.wrapper.getBoundingClientRect()\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\n        }\n\n        const rect = node.getBoundingClientRect()\n\n        target =\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\n      }\n    }\n\n    if (typeof target !== 'number') return\n\n    target += offset\n    target = Math.round(target)\n\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll\n      }\n    } else {\n      target = clamp(0, target, this.limit)\n    }\n\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target\n      this.setScroll(this.scroll)\n      this.reset()\n      this.emit()\n      onComplete?.()\n      return\n    }\n\n    if (!programmatic) {\n      if (target === this.targetScroll) return\n\n      this.targetScroll = target\n    }\n\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp,\n      onUpdate: (value, { completed }) => {\n        // started\n        if (lock) this.isLocked = true\n        this.isScrolling = true\n\n        // updated\n        this.velocity = value - this.animatedScroll\n        this.direction = Math.sign(this.velocity)\n\n        this.animatedScroll = value\n        this.setScroll(this.scroll)\n\n        if (programmatic) {\n          // wheel during programmatic should stop it\n          this.targetScroll = value\n        }\n\n        // completed\n        if (completed) {\n          if (lock) this.isLocked = false\n          requestAnimationFrame(() => {\n            //avoid double scroll event\n            this.isScrolling = false\n          })\n          this.velocity = 0\n          onComplete?.()\n        }\n\n        this.emit()\n      },\n    })\n  }\n\n  get rootElement() {\n    return this.options.wrapper === window\n      ? this.options.content\n      : this.options.wrapper\n  }\n\n  get limit() {\n    return this.isHorizontal ? this.dimensions.limit.x : this.dimensions.limit.y\n  }\n\n  get isHorizontal() {\n    return this.options.orientation === 'horizontal'\n  }\n\n  get actualScroll() {\n    // value browser takes into account\n    return this.isHorizontal\n      ? this.rootElement.scrollLeft\n      : this.rootElement.scrollTop\n  }\n\n  get scroll() {\n    return this.options.infinite\n      ? modulo(this.animatedScroll, this.limit)\n      : this.animatedScroll\n  }\n\n  get progress() {\n    // avoid progress to be NaN\n    return this.limit === 0 ? 1 : this.scroll / this.limit\n  }\n\n  get isSmooth() {\n    return this.__isSmooth\n  }\n\n  set isSmooth(value) {\n    if (this.__isSmooth !== value) {\n      this.rootElement.classList.toggle('lenis-smooth', value)\n      this.__isSmooth = value\n    }\n  }\n\n  get isScrolling() {\n    return this.__isScrolling\n  }\n\n  set isScrolling(value) {\n    if (this.__isScrolling !== value) {\n      this.rootElement.classList.toggle('lenis-scrolling', value)\n      this.__isScrolling = value\n    }\n  }\n\n  get isStopped() {\n    return this.__isStopped\n  }\n\n  set isStopped(value) {\n    if (this.__isStopped !== value) {\n      this.rootElement.classList.toggle('lenis-stopped', value)\n      this.__isStopped = value\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["clamp", "min", "input", "max", "Math", "Animate", "advance", "deltaTime", "_this$onUpdate", "this", "isRunning", "completed", "lerp", "value", "x", "y", "to", "t", "exp", "round", "currentTime", "linearProgress", "duration", "easedProgress", "easing", "from", "onUpdate", "call", "stop", "fromTo", "debounce", "callback", "delay", "timer", "args", "arguments", "context", "clearTimeout", "setTimeout", "apply", "Dimensions", "constructor", "wrapper", "content", "onWindowResize", "width", "window", "innerWidth", "height", "innerHeight", "onWrapperResize", "clientWidth", "clientHeight", "onContentResize", "element", "document", "documentElement", "scrollHeight", "scrollWidth", "addEventListener", "wrapperResizeObserver", "ResizeObserver", "observe", "contentResizeObserver", "destroy", "_this$wrapperResizeOb", "_this$contentResizeOb", "removeEventListener", "disconnect", "limit", "createNanoEvents", "events", "emit", "event", "callbacks", "i", "length", "on", "cb", "_this$events$event", "push", "_this$events$event2", "filter", "VirtualScroll", "wheelMultiplier", "touchMultiplier", "normalizeWheel", "onTouchStart", "clientX", "clientY", "targetTouches", "touchStart", "lastDelta", "onTouchMove", "deltaX", "deltaY", "emitter", "type", "onTouchEnd", "inertia", "onWheel", "passive", "Lenis", "direction", "gestureDirection", "mouseMultiplier", "smooth", "wheelEventsTarget", "smoothWheel", "smoothTouch", "syncTouch", "syncTouchLerp", "touchInertiaMultiplier", "pow", "infinite", "orientation", "gestureOrientation", "onVirtualScroll", "ctrlKey", "isTouch", "isWheel", "options", "scroll", "composedPath", "find", "node", "hasAttribute", "isStopped", "isLocked", "preventDefault", "isSmooth", "isScrolling", "animate", "delta", "abs", "hasTouchInertia", "velocity", "scrollTo", "targetScroll", "_extends", "programmatic", "onScroll", "lastScroll", "animatedScroll", "actualScroll", "sign", "console", "warn", "lenisVersion", "body", "dimensions", "rootElement", "classList", "add", "virtualScroll", "off", "_this$emitter$events$", "setScroll", "isHorizontal", "scrollLeft", "scrollTop", "reset", "start", "raf", "time", "target", "offset", "immediate", "lock", "onComplete", "force", "includes", "_target", "querySelector", "nodeType", "wrapperRect", "getBoundingClientRect", "left", "top", "rect", "requestAnimationFrame", "d", "progress", "__isSmooth", "toggle", "__isScrolling", "__isStopped"]
}
